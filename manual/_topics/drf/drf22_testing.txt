22. Testing (Тестирование)


Код без тестов сломан по умолчанию.


DRF включает несколько вспомогающих классов, которые расширяют существующую 
структуру Django и улучшают поддержку выполнения API-запросов.


1. APIRequestFactory()
    Расширяет RequestFactory() от Django. Доступные методы: get, post, put, 
    patch, delete, head, options. Методы, содержащие тело запроса, включают 
    аргумент format, что облегчает генерацию запросов, использующих тип 
    содержимого, отличный от многокомпонентных данных формы. По умолчанию 
    доступны форматы multipart и json. По умолчанию используется multipart. 
    Чтобы явно закодировать тело запроса, необходимо использовать content_type. 
    Данные multipart формы будут кодироваться для методов, отличных от post(). 
    Принудительная аутентификация запроса удобнее создания правильных учетных 
    данных для аутентификации. force_authenticate напрямую устанавливает 
    request.user в экземпляр user в памяти. Возвращает HttpRequest, а не 
    Request. По умолчанию запросы не проходят проверку CSRF. Чтобы включить 
    необходимо установить флаг enforce_csrf_checks=True при инициализации.
2. APIClient()
    Расширяет Client() от Django. Доступные методы: get, post, put, patch, 
    delete, head, options. Метод login() работает также как в Client() (
    Позволяет аутентифицировать запросы по SessionAuthentication). Подходит для 
    тестирования тестирования, использующих сеансовую аутентификацию. Метод 
    credentials() используется для установки заголовков, которые будут включены 
    во все запросы тестового клиента. Чтобы очистить, необходимо вызвать еще 
    раз. Метод credentials() подходит для тестирования API, требующих заголовков 
    аутентификации, таких как базовая аутентификация, аутентификация OAuth1a и 
    OAuth2, а также простые схемы аутентификации токенов. Метод 
    force_authenticate(user=None, token=None) используется для обхода 
    аутентификации. По умолчанию проверка CSRF не применяется. Для включения 
    необходимо установить enforce_csrf_checks=True при инициализации. Проверка 
    будет применяться только к аутентифицированным пользователям.
3. RequestsClient()
    DRF включает клиент для взаимодействия с помощью requests. Имеет такой же 
    интерфейс, как если бы вы использовали сессию запросов напрямую. 
    Пользовательские заголовки и данные аутентификации могут быть предоставлены 
    также, как и при использовании requests.Session. Если используется 
    SessionAuthentication, то необходимо включить CSRF-токен для запросов post, 
    put, patch, delete. Например, можно сначала сделать get запрос и получить 
    csrf, а затем указать его в следующем запросе.
4. CoreAPIClient()
    Клиент взаимодействует с API с помощью клиентской библиотеки Python coreapi. 
    Пользовательские заголовки и аутентификации могут использоваться с 
    CoreAPIClient как и с RequestsClient.
5. Тесты API
    DRF включает следующие классы тестов, которые являются зеркальным отражением 
    существующих тестовых классов Django, но используют APIClient вместо Client:
    - APISimpleTestCase
    - APITransactionTestCase
    - APITestCase
    - APILiveServerTestCase
6. URLPatternsTestCase()
    DRF предоставляет класс тестов для изоляции urlpatterns на основе каждого 
    класса. Обратите внимание, что он наследуется от Django SimpleTestCase, и, 
    скорее всего, его придется смешивать с другим классом тестов.

При проверке достоверности тестовых ответов удобнее проверять данные, на основе 
которых был создан ответ, чем проверять полностью отрисованный ответ.
Например, проще проверить response.data:
response = self.client.get('/users/4/')
self.assertEqual(response.data, {'id': 4, 'username': 'lauren'})
Вместо того чтобы проверять результат разбора response.content:
response = self.client.get('/users/4/')
self.assertEqual(json.loads(response.content), {'id': 4, 'username': 'lauren'})

Если тестируется представление, используя APIRequestFactory, возвращаемые ответы 
не будут отрендерены, так как рендеринг ответов шаблона выполняется внутренним 
циклом запроса-ответа Django. Чтобы получить доступ к response.content, сначала 
нужно отрендерить ответ.
view = UserDetail.as_view()
request = factory.get('/users/4')
response = view(request, pk='4')
response.render()  # Cannot access `response.content` without this.
self.assertEqual(response.content, '{"username": "lauren", "id": 4}')

